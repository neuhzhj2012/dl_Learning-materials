### 网络相关
- [HTTP状态码含义](https://juejin.im/post/5a1a84816fb9a04519694a7f)

```
1** 服务器已收到请求，需要请求者继续执行操作；
2** 请求成功，操作被成功接收并处理；
3** 请求重定向，需要进一步的操作以完成请求；
4** 客户端错误；
5** 服务端错误；

```
### 程序加速
- [计算机任务类型](https://zhuanlan.zhihu.com/p/20953544)

1. IO密集型任务指磁盘IO、网络IO占主要的任务，计算量小。比如请求网页、读写文件等。
python中可利用sleep模拟IO密集型任务
2. 计算密集型任务指cpu计算占主要的任务，cpu一直处于满负荷状态。如在一个很大列表中查找元素和加减乘除运算等。

- 并发和并行。单核cpu下的多线程其实只是并发，而不是并行
1. [并发](https://zhuanlan.zhihu.com/p/20953544)是指两个或多个事件在同一时间间隔内发生。
2. [并行](https://zhuanlan.zhihu.com/p/20953544)是指两个或者多个事件在同一时刻发生
- [高并发](https://blog.csdn.net/weixin_38405253/article/details/102426549)是从业务角度去描述系统的能力。

1. 出发点

```
提高业务单位时间的响应能力。比如在线直播服务，同时有上万人观看。
```
- [分布式](https://blog.csdn.net/weixin_38405253/article/details/102426549)是从物理资源的角度去将不同的机器组成一个整体对外服务，技术范围非常广且难度非常大，有了这个基础，高并发、高吞吐等系统很容易构建；

1. 出发点

```
为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段。
```
2. 实现方法:水平扩展和垂直拆分。实现高并发的手段可以采用分布式，也可以采用诸如缓存、CDN等，当然也包括多线程；

```
水平扩展：当一台机器扛不住流量时，就通过添加机器的方式，将流量平分到所有服务器上，所有机器都可以提供相当的服务；

垂直拆分：前端有多种查询需求时，一台机器扛不住，可以将不同的需求分发到不同的机器上，比如A机器处理余票查询的请求，B机器处理支付的请求。
```

- [多线程](https://blog.csdn.net/weixin_38405253/article/details/102426549)则聚焦于如何使用编程语言将CPU调度能力最大化。

1. 出发点

```
高效使用CPU
```
2. 实现方法：从软件或者硬件上实现多个线程并发执行的技术

```
解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行（实际是交替运行的）。
```
- Python多线程处理。Ps:一个python进程只有个一个GIL
```
获取GIL（全局解释器锁）;  
执行代码至sleep或python虚拟机挂起;
释放GIL

```
### 算法
- [回溯法(试探法)](https://zhuanlan.zhihu.com/p/51882471),一种选优搜索法，按选优条件向前搜索，以达到目标。当探索到某步，发现原先选择并不优或达不到目标，就退一步重新选择。这种走不通就退回再走的技术称为回溯法。
1. 回溯点指满足回溯条件的某个状态的点
2. 算法框架

```
函数出口,位于函数的第一行;
递归参数(原数据，中间结果，最终结果，状态变量[，终止变量])。递归操作是用来处理下一次的过程， 所以需要通过参数回溯到当前操作。原数据参数不变，用来作为递归的数据集合。中间结果随着每一次的递归操作而发生改变，如位置信息或中间结果变量。输出参数阶段性改变，在满足回溯条件时改变；
递归函数用于处理当前可能发生的情况。不破坏当前参数值的情况下，判断下一状态的新解。若下一次递归不能找到出口，则把之前相关赋值或其他操作重置为初始状态。
```
- 贪心算法（贪婪法），寻找最优解问题的常用方法，将求解过程分为若干步骤，但每个步骤都用贪心原则选择当前状态下最好的选择，并以此希望最后堆叠除的结果也是最好的。

1. 算法框架

```
从某个解出发； 
采用迭代过程，当可以向目标前进一步时，就根据局部最优策略得到一部分解，缩小问题规模；
将所有解综合起来;
```
- [动态规划](https://www.zhihu.com/question/52165201/answer/288025858)

1. 最优子结构指一个问题的最优解包含其子问题的最优解。
2. 核心是拆分问题，拆分的依据是状态和状态方程的定义。

```
每个规模的问题的解称为一个状态；  
每个不同规模问题的解的关系叫做状态转移方程；
每个新状态都是由“最近一个可能的动作”+“做该动作的上一个状态”确定的，这就是基本的状态转移；
通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推(分冶)方式解决
```
3. 算法实现的本质是由下而上的解法，即按照顺序，从基元问题一步步扩大问题规模，直至问题规模覆盖要求解的问题。
2. 对比递归算法

```
递归算法是自顶向下的解法，一次性解决问题；
遇到子问题时，也需要递归到最底层求解，所以复杂度高；
```
- [排序算法](https://zhuanlan.zhihu.com/p/52884590)

1. 选择排序

```
在子序列中进行，将i大的元素放在第n-i+1的位置(升序排列)
```
2. 插入排序

```
将元素放入排好序的数组中，数组长度加1
```
3. 希尔排序

```
相聚为k的元素组成一个子序列，然后减小k的值直至k=1;
子序列内的排序方式为插入排序;
```
4. 归并排序

```
合并相邻两个元素;        
再合并相邻子序列至最终输出
```
5. 快速排序

```
根据参考元素(首元素)将其他元素聚类，大于它的放一侧，小于它的位于它的另一侧;
对剩余元素执行相同操作
```
6. 堆排序

```
构建大顶堆或小顶堆;
将表示堆结构数组的第一个值和数组的最后一个值互换，数组长度减1，并对子数组重新满足堆结构;
对子数组中的元素执行相同操作;
```
### 数据结构
- 数组

1. 特点：线性结构、元素为相同数据类型
2. 衍生处栈和队列数据结构

- 栈

1. 特点：线性结构、LIFO（Last In First Out）

- 队列

1. 特点：线性结构、FIFO(First In First Out)

- 链表

1. 特点：线性结构
2. 元素组成：数据域和指针域
3. 应用

```
可用来实现文件系统、哈希表和邻接表
```

- 图

1. 特点：多个节点相互连接组成的网络

```
（x,y）表示节点x和节点y的一条边，边本身可能有权值
```
2. 分类：有向图和无向图
3. 存储形式：邻接矩阵和邻接表

- 树
1. 特点：分层的数据结构，由节点和连接节点的边组成
2. 分类

```
平衡树；
二叉树；
二叉查找树；
平衡二叉树；
2-3树；
N叉树；
红黑树；
前缀树，实现快速检索，如字典中的单词查询，搜索引擎的自动补全甚至 IP 路由。
```
3. 与图最大的区域是数据间没有循环

- 哈希表

1. 哈希(Hash)算法将某个对象变换为唯一标识符，该标识符通常用一个短的随机字母和数字组成的字符串来代表。 哈希可以用来实现各种数据结构，最常用的是哈希表
2. 组成：数据和链表
3. 性能决定因素：哈希函数、哈希表大小和哈希冲突处理方式
